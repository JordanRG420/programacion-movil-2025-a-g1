# HU 8: Implementaci√≥n de BaseEntity Gen√©rico

## üßæ Nombre:
HU 8 ‚Äì Implementaci√≥n de clase base gen√©rica para operaciones CRUD

## üìÑ Descripci√≥n:
**Explora Neiva**, necesita **implementar una clase base gen√©rica (`BaseEntity`) con tipo de objeto `T`**, que permita realizar operaciones CRUD comunes (crear, actualizar, eliminar) reutilizables en todas las entidades del sistema que manejen informaci√≥n transaccional o de gesti√≥n, **excepto en la entidad `Usuario`**, ya que esta requiere validaciones y l√≥gicas espec√≠ficas. Esta implementaci√≥n tambi√©n debe contemplar el manejo de **atributos de auditor√≠a** (`createdAt`, `updatedAt`, `deletedAt`, `createdBy`, `updatedBy`, `deletedBy`, y `state`).

---

## üéØ Alcance:
- Implementar una **clase abstracta gen√©rica** reutilizable para CRUD b√°sico en entidades comunes.
- Incluir atributos de auditor√≠a y l√≥gica com√∫n para la trazabilidad de registros.
- Aplicable a todas las entidades del sistema **excepto la entidad `Usuario`**.

---

## ‚úÖ Criterios de Aceptaci√≥n:
- La clase base permite crear, actualizar y eliminar registros de manera gen√©rica usando objeto `T`.
- Se registran correctamente los campos de auditor√≠a en cada operaci√≥n.
- Se demuestra el uso en al menos 2 entidades (por ejemplo: `Producto` y `Factura`).
- La entidad `Usuario` **no debe heredar ni usar** esta base.

---

## üß© Tasks (Tareas):

### üë§ Integrante 1 
1. Dise√±ar la clase abstracta `BaseEntity<T>`:
   - Usar anotaciones JPA como `@MappedSuperclass`, `@Id`, `@GeneratedValue`, etc.
   - Definir el campo `id` gen√©rico o como `Long`, seg√∫n dise√±o del proyecto.
   - Asegurar que sea extendible por otras entidades.

2. Agregar los campos de auditor√≠a:
   - `createdAt`, `updatedAt`, `deletedAt`, `createdBy`, `updatedBy`, `deletedBy`, `state`.
   - Anotaciones: `@Column`, `@Temporal`, `@PrePersist`, `@PreUpdate`, etc.
   - Generar `getters` y `setters`.

---

### üë§ Integrante 2 
3. Implementar m√©todos gen√©ricos en un servicio base (`BaseService<T>` o similar):
   - `create(T entity)` para persistencia con control de fechas.
   - `updateById(Long id, T entity)` para actualizaci√≥n.
   - `deleteById(Long id)` para eliminaci√≥n l√≥gica (cambio de estado y `deletedAt`).

4. Probar en una clase de prueba (o con Postman) el correcto funcionamiento de estos m√©todos usando una entidad como ejemplo (`Producto` o `Factura`).

---

### üë§ Integrante 3 
5. Aplicar la herencia de `BaseEntity` en entidades del sistema:
   - `Producto`, `Factura`, `DetalleFactura`, `Categoria`, etc.
   - Asegurar que estas entidades no redefinan los atributos heredados.

6. Excluir la entidad `Usuario` del uso de `BaseEntity`:
   - Justificar por qu√© se excluye (por seguridad, estructura propia, autenticaci√≥n personalizada).
   - Verificar que `Usuario` funcione correctamente sin `BaseEntity`.

---

### üë§ Integrante 4 
7. Documentar esta historia de usuario en el repositorio (o Trello):
   - Agregar descripci√≥n, alcance, criterios de aceptaci√≥n y tareas.
   - Adjuntar ejemplos de uso de los m√©todos gen√©ricos en c√≥digo.
   - Documentar c√≥mo se hereda la clase y se reutiliza el CRUD.
   - Comprobar que est√© clara la exclusi√≥n de `Usuario`.
---

## üìå Nota:
Esta historia de usuario permite consolidar el principio de **reutilizaci√≥n de c√≥digo** en el sistema de carrito de compras, mediante una clase gen√©rica que centraliza las operaciones comunes a todas las entidades, garantizando coherencia en el manejo de auditor√≠a y facilitando la escalabilidad del sistema. La exclusi√≥n de la entidad `Usuario` se justifica por la necesidad de un tratamiento especial en temas de seguridad y autenticaci√≥n.

---

## üíª Ejemplo de C√≥digo Java

### 1. Clase Base de Auditor√≠a

```java
@MappedSuperclass
public abstract class AuditoriaBase {

    @Column(name = "created_at")
    protected LocalDateTime createdAt;

    @Column(name = "updated_at")
    protected LocalDateTime updatedAt;

    @Column(name = "deleted_at")
    protected LocalDateTime deletedAt;

    @Column(name = "created_by")
    protected String createdBy;

    @Column(name = "updated_by")
    protected String updatedBy;

    @Column(name = "deleted_by")
    protected String deletedBy;

    @Column(name = "state")
    protected boolean state = true;

    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }

    // Getters y Setters...
}


public abstract class GenericService<T, ID> {

    @Autowired
    protected JpaRepository<T, ID> repository;

    public T create(T entity) {
        return repository.save(entity);
    }

    public Optional<T> updateById(ID id, T newEntity) {
        if (repository.existsById(id)) {
            return Optional.of(repository.save(newEntity));
        }
        return Optional.empty();
    }

    public boolean deleteById(ID id) {
        Optional<T> entity = repository.findById(id);
        if (entity.isPresent()) {
            if (entity.get() instanceof AuditoriaBase) {
                AuditoriaBase base = (AuditoriaBase) entity.get();
                base.setDeletedAt(LocalDateTime.now());
                base.setState(false);
                repository.save((T) base);
                return true;
            }
        }
        return false;
    }
}


@Entity
public class Producto extends AuditoriaBase {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String nombre;
    private Double precio;

    // Otros atributos, getters y setters
}


@Repository
public interface ProductoRepository extends JpaRepository<Producto, Long> {}

@Service
public class ProductoService extends GenericService<Producto, Long> {}

---