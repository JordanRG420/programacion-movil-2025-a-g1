	Configuraci√≥n CORS en el Backend (AppConfig.java)
El Cross-Origin Resource Sharing (CORS) es un mecanismo de seguridad que controla qu√© dominios externos pueden acceder a los recursos del backend. 

	-Seguridad: Restringe el acceso solo a los or√≠genes permitidos

	-Flexibilidad: Permite que el frontend  se comunique con el backend sin bloqueos del navegador.

	-Credenciales: setAllowCredentials(true) habilita el env√≠o de cookies/tokens (√∫til para autenticaci√≥n).

	
------------------------------------------------------------------
@Configuration  // Indica que esta clase define beans de configuraci√≥n para Spring.
@Bean Marca el m√©todo corsConfigurationSource() como un bean gestionado por Spring.

public CorsConfigurationSource corsConfigurationSource()

M√©todo que crea y retorna la configuraci√≥n CORS.
------------------------------------------------------------------
config.setAllowedOrigins(Arrays.asList(...));
Define los or√≠genes permitidos (frontend):

http://localhost:8100: Direcci√≥n del servidor de desarrollo de Ionic.

capacitor://localhost: Para apps m√≥viles compiladas con Capacitor.

http://localhost: Para emuladores o pruebas locales.
------------------------------------------------------------------
config.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "OPTIONS"));

M√©todos HTTP permitidos: CRUD + OPTIONS

Se utilizan para verificar si el servidor permite la solicitud de origen cruzado antes de enviarla

------------------------------------------------------------------

config.setAllowedHeaders(Arrays.asList("Content-Type", "Authorization", "X-Requested-With", "Accept"));

Headers permitidos en las solicitudes:

Content-Type: Indica el tipo de dato (ej: application/json).

Authorization: Para enviar tokens JWT.

X-Requested-With: Identifica peticiones AJAX. se utiliza para realizar peticiones HTTP as√≠ncronas

Accept: Especifica el tipo de respuesta esperada.

----------------------------------------------------------------------
config.setAllowCredentials(true);

Permite el env√≠o de cookies/tokens de autenticaci√≥n (necesario para sesiones o JWT).
------------------------------------------------------------------------
config.setMaxAge(3600L);

Cachea la configuraci√≥n CORS por 1 hora (3600 segundos), optimizando peticiones futuras.
CORS (Cross-Origin Resource Sharing):
Es un mecanismo de seguridad del navegador que permite que un sitio web acceda a recursos de otro dominio diferente. La configuraci√≥n CORS controla qu√© or√≠genes son permitidos para acceder a los recursos del servidor. 
setMaxAge(3600L):
Esta l√≠nea de c√≥digo establece un valor para la cabecera HTTP Access-Control-Max-Age. Esta cabecera indica al navegador cu√°nto tiempo puede almacenar en cach√© la configuraci√≥n CORS antes de volver a solicitarla al servidor. 
3600L:

------------------------------------------------------------------------
registerCorsConfiguration("/**", config)

Asocia la configuraci√≥n config a todas las rutas del backend (/**).

--------------------------------------------------------------------------
return source para:

Verificar or√≠genes en cada petici√≥n.

A√±adir headers CORS a las respuestas.

Permitir m√©todos HTTP definidos.
--------------------------------------------------------------

Uso de Axios en el servicio:

	Backend (Spring Boot) recibe la solicitud

El CORS Filter verifica que el origen (http://localhost:8100) est√© permitido.

El Controller procesa la petici√≥n y delega al Service.

El Service consulta la base de datos y estructura la respuesta con ApiResponseDto.

-	CORS asegura que solo tu frontend pueda acceder al backend.

-	ApiResponseDto estandariza las respuestas para un manejo f√°cil en el frontend.

-	Axios + Pinia gestionan las peticiones y el estado de forma reactiva.


*************************************************************************************
		Frontend
api.ts 
Responsabilidad: Configuraci√≥n global de Axios para llamadas HTTP.
Interacciones:

Define la URL base del backend (http://localhost:9000/api).

A√±ade interceptores para manejar errores y transformar peticiones/respuestas.

Los interceptores en tu frontend Ionic Vue son esenciales para:
‚úÖ Mantener c√≥digo limpio (evitar repetici√≥n).
‚úÖ Gestionar errores de forma consistente.
‚úÖ A√±adir l√≥gica transversal (ej: autenticaci√≥n).

Los interceptores son funciones que permiten interceptar y modificar peticiones HTTP (request) o respuestas (response) antes de que sean manejadas por tu aplicaci√≥n. 
** Interceptor de Peticiones (Request)** Casos de Uso:
A√±adir headers comunes (ej: Content-Type, Authorization).

Modificar datos antes de enviarlos (ej: formatear fechas).

Loggear peticiones para debug.

**Interceptor de Respuestas** (Response): Estandarizar respuestas: Extraer data de la respuesta.

Manejar errores HTTP (401, 404, 500) de forma centralizada.

Transformar datos (ej: convertir fechas de string a Date).

---------------------------------------------------------------

const api: AxiosInstance = axios.create({
  baseURL: 'http://localhost:9000/api', // Ruta asignada al backend
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json',
  },
});
axios.create({...}): Crea una instancia con configuraci√≥n propia (puedes tener varias diferentes si lo necesitas).

baseURL: Es la direcci√≥n base del backend. Todas las rutas se escribir√°n a partir de aqu√≠ (por ejemplo, api.get('/usuarios') har√° una petici√≥n a http://localhost:9000/api/usuarios).

timeout: Establece el tiempo m√°ximo de espera (en milisegundos). Si la respuesta tarda m√°s de 10 segundos (10000 ms), se cancela.

headers: Define los encabezados por defecto de cada petici√≥n. En este caso, todas las peticiones ser√°n de tipo JSON.

---------------------------------------------------------------
üö® Interceptores de respuesta para manejar errores
ts
Copiar
Editar
api.interceptors.response.use(
  (response) => {
    return response.data;
  },
Interceptores (interceptors.response.use): Permiten modificar la respuesta antes de que llegue al c√≥digo que la llam√≥.

El primer par√°metro es una funci√≥n que se ejecuta si la respuesta es exitosa.

return response.data: Devuelve solo los datos de la respuesta (quita la ‚Äúenvoltura‚Äù que normalmente trae response como status, headers, etc.).

---------------------------------------------------------------------
  (error) => {
    const errorMessage = error.response?.data?.message || 
                       error.message || 
                       'Error de conexi√≥n con el servidor';
Esta parte se ejecuta si la respuesta falla.

Intenta extraer el mensaje de error de la respuesta del backend:

error.response?.data?.message: mensaje personalizado del servidor.

error.message: mensaje gen√©rico del error.

'Error de conexi√≥n con el servidor': mensaje por defecto si no se puede conectar al backend.

--------------------------------------------------------------------
    console.error("Error API:", {
      url: error.config?.url,
      status: error.response?.status,
      message: errorMessage
    });
Muestra en la consola un error detallado que incluye:

La URL que fall√≥.

El c√≥digo de estado (por ejemplo, 404, 500).

El mensaje de error.

/////////////////////////////////////////////////////////////////////////
src/stores/contacts.ts (Pinia)
Responsabilidad: Gestiona el estado global de los contactos y las llamadas al backend. Usa api.ts para hacer peticiones HTTP.

Acci√≥n	¬øQu√© hace?
fetchContacts()	Carga todos los contactos desde el backend.
saveContact()	Crea un nuevo contacto y lo agrega a la lista.
updateContact()	Modifica un contacto existente.
deleteContact()	Elimina un contacto por su ID.


async  se usa para declarar funciones as√≠ncronas, es decir, funciones que no se ejecutan completamente de inmediato, sino que esperan que ciertas operaciones (como llamadas al servidor) terminen antes de continuar.



--
interface Contact {
  id: number;
  name: string;
  email: string;
  phone_number: string;
  company: string;
  status: boolean;
  createdAt: string;
  updatedAt: string | null;
  deletedAt: string | null;
  createdBy: number;
  updatedBy: number | null;
  deletedBy: number | null;
}
Describe la estructura que tiene un contacto. Es √∫til para que TypeScript valide los datos y te d√© autocompletado.

------------------------------------------------------------------------------------------------------

Un store es un lugar centralizado donde se guarda y gestiona el estado compartido de tu aplicaci√≥n.
   Estado inicial
ts
Copiar
Editar
state: () => ({
  contacts: [] as Contact[],
  loading: false,
  error: null as string | null,
}),
contacts: lista de contactos cargados desde el backend.

loading: bandera para saber si se est√° cargando algo.

error: mensaje de error en caso de fallas.


------------------------------------------------------------------------------------------------------

async fetchContacts(force = false) {
  try {
    if (this.contacts.length === 0 || force) {
      this.loading = true;
      this.error = null;
      const response = await api.get<Contact[]>('/contact');
      this.contacts = response.data;
      console.log("Contactos cargados desde backend:", this.contacts);
    }
  } catch (error) {
    this.error = 'Error al cargar contactos';
    console.error("Error al cargar contactos:", error);
    throw error;
  } finally {
    this.loading = false;
  }
}
Carga los contactos desde el servidor.

Solo lo hace si la lista est√° vac√≠a o si se fuerza (force = true).

Usa this.contacts = response.data para guardar los datos en el estado.

Si hay error, guarda un mensaje y lo lanza para que el componente lo pueda manejar.


-------------------------------------------------------------------------------------------------------

async saveContact(contact: Omit<Contact, 'id'>) {
  try {
    const payload = {
      ...contact,
      status: true
    };
    
    const response = await api.post<Contact>('/contact', payload);
    this.contacts = [...this.contacts, response.data];
    return response;
  } catch (error) {
    console.error('Error guardando contacto:', error);
    throw error;
  }
}
Guarda un nuevo contacto.

Omit<Contact, 'id'>: omite el campo id porque el backend lo genera autom√°ticamente.

A√±ade el nuevo contacto al final de la lista actual (this.contacts).


------------------------------------------------------------------------------------------------------
async updateContact(id: number, contact: Partial<Contact>) {
  try {
    const payload = {
      ...contact,
      status: true
    };
    
    const response = await api.put<Contact>(`/contact/${id}`, payload);
    
    this.contacts = this.contacts.map(c => 
      c.id === id ? { ...c, ...response.data } : c
    );
    
    return response;
  } catch (error) {
    console.error('Error actualizando contacto:', error);
    throw error;
  }
}
Actualiza un contacto existente.

Usa PUT para enviar los nuevos datos al servidor.

Actualiza el contacto en la lista local usando map.

Recorre la lista this.contacts con .map(), que devuelve un nuevo arreglo del mismo tama√±o.

Por cada contacto c en la lista:

Compara si el id del contacto actual es igual al id recibido.

Si es igual (es el contacto que quieres actualizar):

Devuelve un nuevo objeto combinado con:

Todos los datos actuales (...c).

Sobrescritos o actualizados con los datos nuevos del backend (...response.data).

-------------------------------------------------------------------------------

async deleteContact(id: number) {
  try {
    await api.delete(`/contact/${id}`);
    this.contacts = this.contacts.filter(c => c.id !== id);
  } catch (error) {
    console.error('Error al eliminar contacto:', error);
    throw error;
  }
}
Elimina un contacto por su id.

Despu√©s de eliminarlo en el servidor, lo remueve de la lista local con filter.


//////////////////////////////////////////////////////////////////////////////////////////
src/views/ContactList.vue
Responsabilidad: Muestra la lista de contactos y maneja interacciones.
Interacciones:

Usa el store (Pinia) para cargar datos.

Llama a acciones como fetchContacts() o deleteContact().

//////////////////////////////////////////////////////////////////////////////////////////
src/components/ContactItem.vue
Responsabilidad: Renderiza un contacto individual.
Interacciones:

Recibe datos del padre (ContactList.vue).

Emite eventos para editar/eliminar (que luego se comunican con el backend).
//////////////////////////////////////////////////////////////////////////////////////////

src/views/ContactForm.vue
Responsabilidad: Formulario para crear/editar contactos.
Interacciones:

Usa el store para enviar datos al backend (saveContact()/updateContact()).
